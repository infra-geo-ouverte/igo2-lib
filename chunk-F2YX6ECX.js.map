{
  "version": 3,
  "sources": ["packages/common/tool/src/shared/toolbox.ts", "packages/common/tool/src/shared/tool.service.ts", "packages/common/tool/src/shared/tool-component.ts", "packages/common/tool/src/toolbox/toolbox.animation.ts", "packages/common/tool/src/toolbox/toolbox.component.ts", "packages/common/tool/src/toolbox/toolbox.component.html"],
  "sourcesContent": ["import { EntityRecord, EntityStore } from '@igo2/common/entity';\n\nimport { BehaviorSubject, Subscription } from 'rxjs';\n\nimport { Tool, ToolboxOptions } from './tool.interface';\n\n/**\n * Service where all available tools and their component are registered.\n */\nexport class Toolbox {\n  /**\n   * Observable of the active tool\n   */\n  activeTool$ = new BehaviorSubject<Tool>(undefined);\n\n  /**\n   * Ordered list of tool names to display in a toolbar\n   */\n  toolbar$ = new BehaviorSubject<string[]>([]);\n\n  /**\n   * Observable of the active tool\n   */\n  private activeTool$$: Subscription;\n\n  /**\n   * Active tool history. Useful for activating the previous tool.\n   */\n  private activeToolHistory: string[] = [];\n  private previousToolName: string;\n  private currentToolName: string;\n\n  /**\n   * Tool store\n   */\n  private store = new EntityStore<Tool>([], {\n    getKey: (tool: Tool) => tool.name\n  });\n\n  get tools$(): BehaviorSubject<Tool[]> {\n    return this.store.entities$;\n  }\n\n  constructor(private options: ToolboxOptions = {}) {\n    this.setToolbar(options.toolbar);\n    this.initStore();\n  }\n\n  /**\n   * Destroy the toolbox\n   */\n  destroy() {\n    this.activeTool$$.unsubscribe();\n    this.store.destroy();\n  }\n\n  /**\n   * Return a tool\n   * @param name Tool name\n   * @returns tool Tool\n   */\n  getTool(name: string): Tool {\n    return this.store.get(name);\n  }\n\n  /**\n   * Return all tools\n   * @returns Array of tools\n   */\n  getTools(): Tool[] {\n    return this.store.all();\n  }\n\n  /**\n   * Set tool configurations\n   * @param tools Tools\n   */\n  setTools(tools: Tool[]) {\n    this.store.load(tools);\n  }\n\n  /**\n   * Get toolbar\n   * @returns Toolbar value\n   */\n  getToolbar(): string[] {\n    return this.toolbar$.getValue();\n  }\n\n  /**\n   * Set toolbar\n   * @param toolbar A list of tool names\n   */\n  setToolbar(toolbar: string[]) {\n    this.toolbar$.next(toolbar || []);\n  }\n\n  /**\n   * Activate a tool (and deactivate other tools)\n   * @param name Tool name\n   * @param options Tool options\n   */\n  activateTool(name: string, options: Record<string, any> = {}) {\n    const tool = this.getTool(name);\n    if (tool === undefined) {\n      return;\n    }\n\n    this.store.state.update(tool, { active: true, options }, true);\n  }\n\n  /**\n   * Activate the previous tool, if any\n   */\n  activatePreviousTool() {\n    if (this.activeToolHistory.length <= 1) {\n      this.deactivateTool();\n      return;\n    }\n    const [previous] = this.activeToolHistory.splice(-2, 2);\n    this.activateTool(previous);\n  }\n\n  getCurrentPreviousToolName(): [string, string] {\n    return [this.previousToolName, this.currentToolName];\n  }\n\n  /**\n   * Activate the tool below, if any\n   */\n  /* activateBelowTool() {\n    const arrayTools = this.getToolbar();\n    const index = arrayTools.findIndex(t => t === this.activeTool$.getValue().name);\n    if (arrayTools[index + 1] !== undefined) {\n      this.deactivateTool();\n      const below = arrayTools[index + 1];\n      this.activateTool(below);\n    } else {\n      this.deactivateTool();\n      const below = arrayTools[0];\n      this.activateTool(below);\n    }\n  } */\n\n  /**\n   * Activate the tool above, if any\n   */\n  /* activateAboveTool() {\n    const arrayTools = this.getToolbar();\n    const index = arrayTools.findIndex(t => t === this.activeTool$.getValue().name);\n    if (arrayTools[index - 1] !== undefined) {\n      this.deactivateTool();\n      const above = arrayTools[index - 1];\n      this.activateTool(above);\n    } else {\n      this.deactivateTool();\n      const above = arrayTools[arrayTools.length - 1];\n      this.activateTool(above);\n    }\n  } */\n\n  /**\n   * Deactivate the active tool\n   */\n  deactivateTool() {\n    this.clearActiveToolHistory();\n    this.store.state.updateAll({ active: false });\n  }\n\n  /**\n   * Initialize the tool store and start observing the active tool\n   */\n  private initStore() {\n    this.store = new EntityStore<Tool>([], {\n      getKey: (entity: Tool) => entity.name\n    });\n\n    this.activeTool$$ = this.store.stateView\n      .firstBy$((record: EntityRecord<Tool>) => record.state.active === true)\n      .subscribe((record: EntityRecord<Tool>) => {\n        if (record === undefined) {\n          this.setActiveTool(undefined);\n          return;\n        }\n\n        const tool = record.entity;\n        const options = Object.assign(\n          {},\n          tool.options || {},\n          record.state.options || {}\n        );\n        this.setActiveTool(Object.assign({}, tool, { options }));\n      });\n  }\n\n  /**\n   * Set the active tool and update the tool history\n   * @param tool Tool\n   */\n  private setActiveTool(tool: Tool | undefined) {\n    this.activeTool$.next(tool);\n    if (tool === undefined) {\n      this.clearActiveToolHistory();\n    } else {\n      this.activeToolHistory = this.activeToolHistory\n        .filter((name: string) => name !== tool.name)\n        .concat([tool.name]);\n\n      this.previousToolName = this.currentToolName;\n      this.currentToolName =\n        this.activeToolHistory[this.activeToolHistory.length - 1];\n    }\n  }\n\n  /**\n   * Clear the tool history\n   */\n  private clearActiveToolHistory() {\n    this.activeToolHistory = [];\n  }\n}\n", "import { Injectable } from '@angular/core';\n\nimport { Tool } from './tool.interface';\nimport { Toolbox } from './toolbox';\n\n/**\n * Service where runtime tool configurations are registered\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class ToolService {\n  static tools: Record<string, Tool> = {};\n\n  /**\n   * Toolbox that holds main tools\n   */\n  public toolbox: Toolbox = new Toolbox();\n\n  static register(tool: Tool) {\n    ToolService.tools[tool.name] = tool;\n  }\n\n  constructor() {\n    this.toolbox.setTools(this.getTools());\n  }\n\n  /**\n   * Return a tool\n   * @param name Tool name\n   * @returns tool Tool\n   */\n  getTool(name: string): Tool {\n    return ToolService.tools[name];\n  }\n\n  /**\n   * Return all tools\n   * @returns tTols\n   */\n  getTools(): Tool[] {\n    return Object.values(ToolService.tools);\n  }\n}\n", "import { Tool } from './tool.interface';\nimport { ToolService } from './tool.service';\n\nexport function ToolComponent(tool: Partial<Tool>): (cls: any) => any {\n  return (compType: any) => {\n    ToolService.register(\n      Object.assign({}, tool, {\n        component: compType\n      } as Tool)\n    );\n  };\n}\n", "import {\n  AnimationTriggerMetadata,\n  animate,\n  state,\n  style,\n  transition,\n  trigger\n} from '@angular/animations';\n\nexport function toolSlideInOut(\n  speed = '300ms',\n  type = 'ease-in-out'\n): AnimationTriggerMetadata {\n  return trigger('toolSlideInOut', [\n    state(\n      'enter',\n      style({\n        transform: 'translate3d(0, 0, 0)'\n      })\n    ),\n    transition('void => enter', animate(speed + ' ' + type))\n  ]);\n}\n", "import { AsyncPipe, NgClass, NgIf } from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  HostBinding,\n  Input,\n  OnDestroy,\n  OnInit\n} from '@angular/core';\n\nimport { Action, ActionStore, ActionbarComponent } from '@igo2/common/action';\nimport { DynamicOutletComponent } from '@igo2/common/dynamic-component';\n\nimport { BehaviorSubject, Observable, Subscription } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { Tool } from '../shared/tool.interface';\nimport { Toolbox } from '../shared/toolbox';\nimport { ToolboxColor } from '../shared/toolbox.enums';\nimport { toolSlideInOut } from './toolbox.animation';\n\n@Component({\n  selector: 'igo-toolbox',\n  templateUrl: 'toolbox.component.html',\n  styleUrls: ['toolbox.component.scss'],\n  animations: [toolSlideInOut()],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  standalone: true,\n  imports: [\n    NgIf,\n    ActionbarComponent,\n    NgClass,\n    DynamicOutletComponent,\n    AsyncPipe\n  ]\n})\nexport class ToolboxComponent implements OnInit, OnDestroy {\n  /**\n   * Observable of the active tool\n   */\n  activeTool$ = new BehaviorSubject<Tool>(undefined);\n\n  get isActive(): boolean {\n    return !!this.activeTool$.value;\n  }\n\n  /**\n   * Store of actions that toggle tools\n   */\n  actionStore: ActionStore = new ActionStore([]);\n\n  /**\n   * Observable of he anmation state\n   */\n  animation$ = new BehaviorSubject<string>('none');\n\n  /**\n   * Observable of the toolbar\n   */\n  toolbar$ = new BehaviorSubject<string[]>([]);\n\n  /**\n   * Whether the Toolbar should display actions' titles\n   */\n  toolbarWithTitle$: Observable<boolean> = this.activeTool$.pipe(\n    map((tool: Tool | undefined) => tool === undefined)\n  );\n\n  /**\n   * Subscription to the active tool\n   */\n  private activeTool$$: Subscription;\n\n  /**\n   * Subscription to the toolbar\n   */\n  private toolbar$$: Subscription;\n\n  /**\n   * Observable of the ongoing animation. This is useful when\n   * multiple animations are triggered at once i.e. when the user clicks\n   * too fast on different actions\n   */\n  private animating$ = new BehaviorSubject<boolean>(false);\n\n  /**\n   * Subscription to the ongoing animation\n   */\n  private animating$$: Subscription;\n\n  /**\n   * Toolbox\n   */\n  @Input() toolbox: Toolbox;\n\n  /**\n   * Whether the toolbox should animate the first tool entering\n   */\n  @Input() animate = false;\n\n  /**\n   * Color of Toolbox\n   */\n  @Input() color: ToolboxColor = 'white';\n\n  /**\n   * @ignore\n   */\n  @HostBinding('class.color-grey')\n  get classColorGrey() {\n    return this.color === 'grey';\n  }\n\n  /**\n   * @ignore\n   */\n  @HostBinding('class.color-primary')\n  get classColorPrimary() {\n    return this.color === 'primary';\n  }\n\n  /**\n   * Initialize the toolbar and subscribe to the active tool\n   * @internal\n   */\n  ngOnInit() {\n    this.toolbar$$ = this.toolbox.toolbar$.subscribe((toolbar: string[]) =>\n      this.onToolbarChange(toolbar)\n    );\n    this.activeTool$$ = this.toolbox.activeTool$.subscribe((tool: Tool) =>\n      this.onActiveToolChange(tool)\n    );\n  }\n\n  /**\n   * Unsubscribe to the active tool and destroy the action store\n   * @internal\n   */\n  ngOnDestroy() {\n    this.toolbar$$.unsubscribe();\n    this.activeTool$$.unsubscribe();\n    this.actionStore.destroy();\n  }\n\n  /**\n   * Track the starting animation\n   * @internal\n   */\n  onAnimationStart() {\n    this.animating$.next(true);\n  }\n\n  /**\n   * Untrack the completed animation\n   * @internal\n   */\n  onAnimationComplete() {\n    this.animating$.next(false);\n  }\n\n  /**\n   * Return a tool's inputs\n   * @param tool Tool\n   * @returns Tool inputs\n   * @internal\n   */\n  getToolInputs(tool: Tool): Record<string, any> {\n    return tool.options || {};\n  }\n\n  /**\n   * Initialize an action store\n   * @param toolbar Toolbar\n   */\n  private onToolbarChange(toolbar: string[]) {\n    this.setToolbar(toolbar);\n  }\n\n  /**\n   * Activate a tool and trigger an animation or not\n   * @param tool Tool to activate\n   */\n  private onActiveToolChange(tool: Tool) {\n    if (!this.animate) {\n      this.setActiveTool(tool);\n      return;\n    }\n    this.onAnimate(() => this.setActiveTool(tool));\n  }\n\n  /**\n   * Set the active tool\n   * @param tool Tool to activate\n   */\n  private setActiveTool(tool: Tool | undefined) {\n    if (tool === undefined) {\n      this.actionStore.state.updateAll({ active: false });\n    } else {\n      const action = this.actionStore.get(tool.name);\n      if (action !== undefined) {\n        this.actionStore.state.update(action, { active: true }, true);\n      }\n    }\n\n    this.activeTool$.next(tool);\n    if (this.animate) {\n      this.animation$.next('enter');\n    }\n  }\n\n  /**\n   * Initialize the toolbar\n   */\n  private setToolbar(toolbar: string[]) {\n    const actions = toolbar.reduce((acc: Action[], toolName: string) => {\n      const tool = this.toolbox.getTool(toolName);\n      if (tool === undefined) {\n        return acc;\n      }\n\n      acc.push({\n        id: tool.name,\n        title: tool.title,\n        icon: tool.icon,\n        tooltip: tool.tooltip,\n        args: [tool, this.toolbox],\n        handler: (_tool: Tool, _toolbox: Toolbox) => {\n          _toolbox.activateTool(_tool.name);\n        },\n        ngClass: (_tool: Tool) => {\n          return this.toolbox.activeTool$.pipe(\n            map((activeTool: Tool) => {\n              let toolActivated = false;\n              if (activeTool !== undefined && _tool.name === activeTool.name) {\n                toolActivated = true;\n              }\n\n              let childrenToolActivated = false;\n              if (\n                activeTool !== undefined &&\n                _tool.name === activeTool.parent\n              ) {\n                childrenToolActivated = true;\n              }\n\n              return {\n                'tool-activated': toolActivated,\n                'children-tool-activated': childrenToolActivated\n              };\n            })\n          );\n        }\n      });\n      return acc;\n    }, []);\n    this.actionStore.load(actions);\n    this.toolbar$.next(toolbar);\n  }\n\n  /**\n   * Observe the ongoing animation and ignore any incoming animation\n   * while one is still ongoing.\n   * @param callback Callback to execute when the animation completes\n   */\n  private onAnimate(callback: () => void) {\n    this.unAnimate();\n    this.animating$$ = this.animating$.subscribe((animation: boolean) => {\n      if (!animation) {\n        callback.call(this);\n        this.unAnimate();\n      }\n    });\n  }\n\n  /**\n   * Stop observing an animation when it's complete\n   */\n  private unAnimate() {\n    if (this.animating$$) {\n      this.animating$$.unsubscribe();\n    }\n  }\n}\n", "<igo-actionbar\n  *ngIf=\"(toolbar$ | async).length > 0\"\n  [store]=\"actionStore\"\n  [withIcon]=\"true\"\n  [withTitle]=\"toolbarWithTitle$ | async\"\n  [withTooltip]=\"(toolbarWithTitle$ | async) === false\"\n  [scrollActive]=\"toolbarWithTitle$ | async\"\n  [horizontal]=\"false\"\n>\n</igo-actionbar>\n\n<div\n  *ngIf=\"activeTool$ | async as tool\"\n  class=\"igo-tool-container mat-body-1\"\n  [ngClass]=\"{\n    'igo-tool-container-with-toolbar': !actionStore.empty,\n    'igo-tool-container-with-animation': animate\n  }\"\n  [@toolSlideInOut]=\"animation$ | async\"\n  (@toolSlideInOut.start)=\"onAnimationStart()\"\n  (@toolSlideInOut.done)=\"onAnimationComplete()\"\n>\n  <igo-dynamic-outlet\n    [component]=\"tool.component\"\n    [inputs]=\"getToolInputs(tool)\"\n  >\n  </igo-dynamic-outlet>\n</div>\n"],
  "mappings": "+TASM,IAAOA,EAAP,KAAc,CAkCEC,QA9BpBC,YAAc,IAAIC,EAAsBC,MAAS,EAKjDC,SAAW,IAAIF,EAA0B,CAAA,CAAE,EAKnCG,aAKAC,kBAA8B,CAAA,EAC9BC,iBACAC,gBAKAC,MAAQ,IAAIC,EAAkB,CAAA,EAAI,CACxCC,OAASC,GAAeA,EAAKC,KAC9B,EAED,IAAIC,QAAM,CACR,OAAO,KAAKL,MAAMM,SACpB,CAEAC,YAAoBhB,EAA0B,CAAA,EAAE,CAA5B,KAAAA,QAAAA,EAClB,KAAKiB,WAAWjB,EAAQkB,OAAO,EAC/B,KAAKC,UAAS,CAChB,CAKAC,SAAO,CACL,KAAKf,aAAagB,YAAW,EAC7B,KAAKZ,MAAMW,QAAO,CACpB,CAOAE,QAAQT,EAAY,CAClB,OAAO,KAAKJ,MAAMc,IAAIV,CAAI,CAC5B,CAMAW,UAAQ,CACN,OAAO,KAAKf,MAAMgB,IAAG,CACvB,CAMAC,SAASC,EAAa,CACpB,KAAKlB,MAAMmB,KAAKD,CAAK,CACvB,CAMAE,YAAU,CACR,OAAO,KAAKzB,SAAS0B,SAAQ,CAC/B,CAMAb,WAAWC,EAAiB,CAC1B,KAAKd,SAAS2B,KAAKb,GAAW,CAAA,CAAE,CAClC,CAOAc,aAAanB,EAAcb,EAA+B,CAAA,EAAE,CAC1D,IAAMY,EAAO,KAAKU,QAAQT,CAAI,EAC1BD,IAAST,QAIb,KAAKM,MAAMwB,MAAMC,OAAOtB,EAAM,CAAEuB,OAAQ,GAAMnC,QAAAA,CAAO,EAAI,EAAI,CAC/D,CAKAoC,sBAAoB,CAClB,GAAI,KAAK9B,kBAAkB+B,QAAU,EAAG,CACtC,KAAKC,eAAc,EACnB,MACF,CACA,GAAM,CAACC,CAAQ,EAAI,KAAKjC,kBAAkBkC,OAAO,GAAI,CAAC,EACtD,KAAKR,aAAaO,CAAQ,CAC5B,CAEAE,4BAA0B,CACxB,MAAO,CAAC,KAAKlC,iBAAkB,KAAKC,eAAe,CACrD,CAuCA8B,gBAAc,CACZ,KAAKI,uBAAsB,EAC3B,KAAKjC,MAAMwB,MAAMU,UAAU,CAAER,OAAQ,EAAK,CAAE,CAC9C,CAKQhB,WAAS,CACf,KAAKV,MAAQ,IAAIC,EAAkB,CAAA,EAAI,CACrCC,OAASiC,GAAiBA,EAAO/B,KAClC,EAED,KAAKR,aAAe,KAAKI,MAAMoC,UAC5BC,SAAUC,GAA+BA,EAAOd,MAAME,SAAW,EAAI,EACrEa,UAAWD,GAA8B,CACxC,GAAIA,IAAW5C,OAAW,CACxB,KAAK8C,cAAc9C,MAAS,EAC5B,MACF,CAEA,IAAMS,EAAOmC,EAAOH,OACd5C,EAAUkD,OAAOC,OACrB,CAAA,EACAvC,EAAKZ,SAAW,CAAA,EAChB+C,EAAOd,MAAMjC,SAAW,CAAA,CAAE,EAE5B,KAAKiD,cAAcC,OAAOC,OAAO,CAAA,EAAIvC,EAAM,CAAEZ,QAAAA,CAAO,CAAE,CAAC,CACzD,CAAC,CACL,CAMQiD,cAAcrC,EAAsB,CAC1C,KAAKX,YAAY8B,KAAKnB,CAAI,EACtBA,IAAST,OACX,KAAKuC,uBAAsB,GAE3B,KAAKpC,kBAAoB,KAAKA,kBAC3B8C,OAAQvC,GAAiBA,IAASD,EAAKC,IAAI,EAC3CwC,OAAO,CAACzC,EAAKC,IAAI,CAAC,EAErB,KAAKN,iBAAmB,KAAKC,gBAC7B,KAAKA,gBACH,KAAKF,kBAAkB,KAAKA,kBAAkB+B,OAAS,CAAC,EAE9D,CAKQK,wBAAsB,CAC5B,KAAKpC,kBAAoB,CAAA,CAC3B,GChNF,IAAagD,GAAW,IAAA,CAAlB,MAAOA,CAAW,CACtB,OAAOC,MAA8B,CAAA,EAK9BC,QAAmB,IAAIC,EAE9B,OAAOC,SAASC,EAAU,CACxBL,EAAYC,MAAMI,EAAKC,IAAI,EAAID,CACjC,CAEAE,aAAA,CACE,KAAKL,QAAQM,SAAS,KAAKC,SAAQ,CAAE,CACvC,CAOAC,QAAQJ,EAAY,CAClB,OAAON,EAAYC,MAAMK,CAAI,CAC/B,CAMAG,UAAQ,CACN,OAAOE,OAAOC,OAAOZ,EAAYC,KAAK,CACxC,4CA/BWD,EAAW,6BAAXA,EAAWa,QAAXb,EAAWc,UAAAC,WAFV,MAAM,CAAA,SAEPf,CAAW,GAAA,ECRlB,SAAUgB,GAAcC,EAAmB,CAC/C,OAAQC,GAAiB,CACvBC,EAAYC,SACVC,OAAOC,OAAO,CAAA,EAAIL,EAAM,CACtBM,UAAWL,EACJ,CAAC,CAEd,CACF,CCFM,SAAUM,EACdC,EAAQ,QACRC,EAAO,cAAa,CAEpB,OAAOC,EAAQ,iBAAkB,CAC/BC,EACE,QACAC,EAAM,CACJC,UAAW,uBACZ,CAAC,EAEJC,EAAW,gBAAiBC,EAAQP,EAAQ,IAAMC,CAAI,CAAC,CAAC,CACzD,CACH,qHEtBAO,EAAA,EAAA,gBAAA,CAAA,yDAEEC,EAAA,QAAAC,EAAAC,WAAA,EAAqB,WAAA,EAAA,EACJ,YAAAC,EAAA,EAAA,EAAAF,EAAAG,iBAAA,CAAA,EACsB,cAAAD,EAAA,EAAA,EAAAF,EAAAG,iBAAA,IAAA,EAAA,EACc,eAAAD,EAAA,EAAA,GAAAF,EAAAG,iBAAA,CAAA,EACX,aAAA,EAAA,qCAK5CC,EAAA,EAAA,MAAA,CAAA,eAQEC,EAAA,wBAAA,UAAA,CAAAC,EAAAC,CAAA,EAAA,IAAAP,EAAAQ,EAAA,EAAA,OAAAC,EAAyBT,EAAAU,iBAAA,CAAkB,CAAA,CAAA,EAAC,uBAAA,UAAA,CAAAJ,EAAAC,CAAA,EAAA,IAAAP,EAAAQ,EAAA,EAAA,OAAAC,EACpBT,EAAAW,oBAAA,CAAqB,CAAA,CAAA,EAE7Cb,EAAA,EAAA,qBAAA,CAAA,EAKFc,EAAA,6BAbEb,EAAA,UAAAc,EAAA,EAAAC,EAAA,CAAAd,EAAAC,YAAAc,MAAAf,EAAAgB,OAAA,CAAA,EAGE,kBAAAd,EAAA,EAAA,EAAAF,EAAAiB,UAAA,CAAA,EAMAC,EAAA,CAAA,EAAAnB,EAAA,YAAAoB,EAAAC,SAAA,EAA4B,SAAApB,EAAAqB,cAAAF,CAAA,CAAA,GDahC,IAAaG,GAAgB,IAAA,CAAvB,MAAOA,CAAgB,CAI3BC,YAAc,IAAIC,EAAsBC,MAAS,EAEjD,IAAIC,UAAQ,CACV,MAAO,CAAC,CAAC,KAAKH,YAAYI,KAC5B,CAKA1B,YAA2B,IAAI2B,EAAY,CAAA,CAAE,EAK7CX,WAAa,IAAIO,EAAwB,MAAM,EAK/CK,SAAW,IAAIL,EAA0B,CAAA,CAAE,EAK3CrB,kBAAyC,KAAKoB,YAAYO,KACxDC,EAAKC,GAA2BA,IAASP,MAAS,CAAC,EAM7CQ,aAKAC,UAOAC,WAAa,IAAIX,EAAyB,EAAK,EAK/CY,YAKCC,QAKArB,QAAU,GAKVsB,MAAsB,QAK/B,IACIC,gBAAc,CAChB,OAAO,KAAKD,QAAU,MACxB,CAKA,IACIE,mBAAiB,CACnB,OAAO,KAAKF,QAAU,SACxB,CAMAG,UAAQ,CACN,KAAKP,UAAY,KAAKG,QAAQR,SAASa,UAAWC,GAChD,KAAKC,gBAAgBD,CAAO,CAAC,EAE/B,KAAKV,aAAe,KAAKI,QAAQd,YAAYmB,UAAWV,GACtD,KAAKa,mBAAmBb,CAAI,CAAC,CAEjC,CAMAc,aAAW,CACT,KAAKZ,UAAUa,YAAW,EAC1B,KAAKd,aAAac,YAAW,EAC7B,KAAK9C,YAAY+C,QAAO,CAC1B,CAMAtC,kBAAgB,CACd,KAAKyB,WAAWc,KAAK,EAAI,CAC3B,CAMAtC,qBAAmB,CACjB,KAAKwB,WAAWc,KAAK,EAAK,CAC5B,CAQA5B,cAAcW,EAAU,CACtB,OAAOA,EAAKkB,SAAW,CAAA,CACzB,CAMQN,gBAAgBD,EAAiB,CACvC,KAAKQ,WAAWR,CAAO,CACzB,CAMQE,mBAAmBb,EAAU,CACnC,GAAI,CAAC,KAAKhB,QAAS,CACjB,KAAKoC,cAAcpB,CAAI,EACvB,MACF,CACA,KAAKqB,UAAU,IAAM,KAAKD,cAAcpB,CAAI,CAAC,CAC/C,CAMQoB,cAAcpB,EAAsB,CAC1C,GAAIA,IAASP,OACX,KAAKxB,YAAYqD,MAAMC,UAAU,CAAEC,OAAQ,EAAK,CAAE,MAC7C,CACL,IAAMC,EAAS,KAAKxD,YAAYyD,IAAI1B,EAAK2B,IAAI,EACzCF,IAAWhC,QACb,KAAKxB,YAAYqD,MAAMM,OAAOH,EAAQ,CAAED,OAAQ,EAAI,EAAI,EAAI,CAEhE,CAEA,KAAKjC,YAAY0B,KAAKjB,CAAI,EACtB,KAAKhB,SACP,KAAKC,WAAWgC,KAAK,OAAO,CAEhC,CAKQE,WAAWR,EAAiB,CAClC,IAAMkB,EAAUlB,EAAQmB,OAAO,CAACC,EAAeC,IAAoB,CACjE,IAAMhC,EAAO,KAAKK,QAAQ4B,QAAQD,CAAQ,EAC1C,OAAIhC,IAASP,QAIbsC,EAAIG,KAAK,CACPC,GAAInC,EAAK2B,KACTS,MAAOpC,EAAKoC,MACZC,KAAMrC,EAAKqC,KACXC,QAAStC,EAAKsC,QACdC,KAAM,CAACvC,EAAM,KAAKK,OAAO,EACzBmC,QAASA,CAACC,EAAaC,IAAqB,CAC1CA,EAASC,aAAaF,EAAMd,IAAI,CAClC,EACAiB,QAAUH,GACD,KAAKpC,QAAQd,YAAYO,KAC9BC,EAAK8C,GAAoB,CACvB,IAAIC,EAAgB,GAChBD,IAAepD,QAAagD,EAAMd,OAASkB,EAAWlB,OACxDmB,EAAgB,IAGlB,IAAIC,EAAwB,GAC5B,OACEF,IAAepD,QACfgD,EAAMd,OAASkB,EAAWG,SAE1BD,EAAwB,IAGnB,CACL,iBAAkBD,EAClB,0BAA2BC,EAE/B,CAAC,CAAC,EAGP,EACMhB,CACT,EAAG,CAAA,CAAE,EACL,KAAK9D,YAAYgF,KAAKpB,CAAO,EAC7B,KAAKhC,SAASoB,KAAKN,CAAO,CAC5B,CAOQU,UAAU6B,EAAoB,CACpC,KAAKC,UAAS,EACd,KAAK/C,YAAc,KAAKD,WAAWO,UAAW0C,GAAsB,CAC7DA,IACHF,EAASG,KAAK,IAAI,EAClB,KAAKF,UAAS,EAElB,CAAC,CACH,CAKQA,WAAS,CACX,KAAK/C,aACP,KAAKA,YAAYW,YAAW,CAEhC,4CArPWzB,EAAgB,2BAAhBA,EAAgBgE,UAAA,CAAA,CAAA,aAAA,CAAA,EAAAC,SAAA,EAAAC,aAAA,SAAAC,EAAAC,EAAA,CAAAD,EAAA,GAAhBE,EAAA,aAAAD,EAAAnD,cAAA,EAAgB,gBAAAmD,EAAAlD,iBAAA,2bCpC7BoD,EAAA,EAAAC,EAAA,EAAA,GAAA,gBAAA,CAAA,eAWAD,EAAA,EAAAE,EAAA,EAAA,EAAA,MAAA,CAAA,sBAVG/F,EAAA,OAAAG,EAAA,EAAA,EAAAwF,EAAA7D,QAAA,EAAAkE,OAAA,CAAA,EAWA7E,EAAA,CAAA,EAAAnB,EAAA,OAAAG,EAAA,EAAA,EAAAwF,EAAAnE,WAAA,CAAA,kBDiBCyE,EACAC,EACAC,EACAC,EACAC,CAAS,EAAAC,OAAA,CAAA;2DAAA,EAAAC,KAAA,CAAAlB,UARC,CAACmB,EAAc,CAAE,CAAC,EAAAC,gBAAA,CAAA,CAAA,SAWnBlF,CAAgB,GAAA",
  "names": ["Toolbox", "options", "activeTool$", "BehaviorSubject", "undefined", "toolbar$", "activeTool$$", "activeToolHistory", "previousToolName", "currentToolName", "store", "EntityStore", "getKey", "tool", "name", "tools$", "entities$", "constructor", "setToolbar", "toolbar", "initStore", "destroy", "unsubscribe", "getTool", "get", "getTools", "all", "setTools", "tools", "load", "getToolbar", "getValue", "next", "activateTool", "state", "update", "active", "activatePreviousTool", "length", "deactivateTool", "previous", "splice", "getCurrentPreviousToolName", "clearActiveToolHistory", "updateAll", "entity", "stateView", "firstBy$", "record", "subscribe", "setActiveTool", "Object", "assign", "filter", "concat", "ToolService", "tools", "toolbox", "Toolbox", "register", "tool", "name", "constructor", "setTools", "getTools", "getTool", "Object", "values", "factory", "\u0275fac", "providedIn", "ToolComponent", "tool", "compType", "ToolService", "register", "Object", "assign", "component", "toolSlideInOut", "speed", "type", "trigger", "state", "style", "transform", "transition", "animate", "\u0275\u0275element", "\u0275\u0275property", "ctx_r0", "actionStore", "\u0275\u0275pipeBind1", "toolbarWithTitle$", "\u0275\u0275elementStart", "\u0275\u0275listener", "\u0275\u0275restoreView", "_r2", "\u0275\u0275nextContext", "\u0275\u0275resetView", "onAnimationStart", "onAnimationComplete", "\u0275\u0275elementEnd", "\u0275\u0275pureFunction2", "_c0", "empty", "animate", "animation$", "\u0275\u0275advance", "tool_r3", "component", "getToolInputs", "ToolboxComponent", "activeTool$", "BehaviorSubject", "undefined", "isActive", "value", "ActionStore", "toolbar$", "pipe", "map", "tool", "activeTool$$", "toolbar$$", "animating$", "animating$$", "toolbox", "color", "classColorGrey", "classColorPrimary", "ngOnInit", "subscribe", "toolbar", "onToolbarChange", "onActiveToolChange", "ngOnDestroy", "unsubscribe", "destroy", "next", "options", "setToolbar", "setActiveTool", "onAnimate", "state", "updateAll", "active", "action", "get", "name", "update", "actions", "reduce", "acc", "toolName", "getTool", "push", "id", "title", "icon", "tooltip", "args", "handler", "_tool", "_toolbox", "activateTool", "ngClass", "activeTool", "toolActivated", "childrenToolActivated", "parent", "load", "callback", "unAnimate", "animation", "call", "selectors", "hostVars", "hostBindings", "rf", "ctx", "\u0275\u0275classProp", "\u0275\u0275template", "ToolboxComponent_igo_actionbar_0_Template", "ToolboxComponent_div_2_Template", "length", "NgIf", "ActionbarComponent", "NgClass", "DynamicOutletComponent", "AsyncPipe", "styles", "data", "toolSlideInOut", "changeDetection"]
}
