import { SubjectStatus } from '@igo2/utils';

import BaseLayer from 'ol/layer/Base';

import { BehaviorSubject, Subject, Subscription, combineLatest } from 'rxjs';

import type { DataSource } from '../../../datasource/shared/datasources/datasource';
import type { MapBase } from '../../../map/shared/map.abstract';
import { getResolutionFromScale } from '../../../map/shared/map.utils';
import type { LayerOptions, LayerType } from './layer.interface';

export type AnyLayerBase = LayerBase | LayerGroupBase;

export abstract class LayerBase {
  abstract type: LayerType;
  abstract ol: BaseLayer;
  abstract parent: LayerGroupBase;
  protected abstract createOlLayer(): BaseLayer;

  public collapsed: boolean;
  public firstLoadComponent = true;
  public map: MapBase;
  public olLoadingProblem = false;
  public status$: Subject<SubjectStatus>;
  dataSource: DataSource | undefined;

  /**
   * Define if a layer is generated by code OR defined by layer/context user layer.
   * Useful for filtering layers list in mapOffline.directive or in the sharemap...
   * return false by default.
   */
  get isIgoInternalLayer(): boolean {
    return this.options.isIgoInternalLayer || false;
  }

  get id(): string {
    return String(this.options.id);
  }

  get parentId(): string {
    return this.parent?.id ?? this.options.parentId;
  }

  get alias(): string {
    return this.options.alias;
  }

  get title(): string {
    return this.options.title;
  }
  set title(title: string) {
    this.options.title = title;
  }

  get zIndex(): number {
    return this.ol.getZIndex();
  }
  set zIndex(zIndex: number) {
    if (zIndex === this.zIndex) {
      return;
    }
    this.ol.setZIndex(zIndex);
  }

  get baseLayer(): boolean {
    return this.options.baseLayer;
  }
  set baseLayer(baseLayer: boolean) {
    this.options.baseLayer = baseLayer;
  }

  get opacity(): number {
    return this.ol.get('opacity');
  }
  set opacity(opacity: number) {
    this.ol.setOpacity(opacity);
  }

  set isInResolutionsRange(value: boolean) {
    this.isInResolutionsRange$.next(value);
  }
  get isInResolutionsRange(): boolean {
    return this.isInResolutionsRange$.value;
  }
  readonly isInResolutionsRange$ = new BehaviorSubject(false);

  set maxResolution(value: number) {
    this.ol.setMaxResolution(value === 0 ? 0 : value || Infinity);
  }
  get maxResolution(): number {
    return this.ol.getMaxResolution();
  }

  set minResolution(value: number) {
    this.ol.setMinResolution(value || 0);
  }
  get minResolution(): number {
    return this.ol.getMinResolution();
  }

  set visible(value: boolean) {
    if (value === this.visible) {
      return;
    }
    this.ol.setVisible(value);
    this._visible$.next(value);
  }
  get visible(): boolean {
    return this._visible$.value;
  }
  private _visible$ = new BehaviorSubject<boolean>(undefined);
  readonly visible$ = this._visible$.asObservable();

  get displayed(): boolean {
    return this._displayed$.value;
  }
  set displayed(value: boolean) {
    if (value === this.displayed) {
      return;
    }
    this._displayed$.next(value);
  }
  private _displayed$ = new BehaviorSubject<boolean>(undefined);
  displayed$ = this._displayed$.asObservable();
  private displayed$$: Subscription;

  get showInLayerList(): boolean {
    return this.options.showInLayerList !== false;
  }

  get saveableOptions(): Partial<LayerOptions> {
    return {
      title: this.options.title,
      zIndex: this.zIndex,
      visible: this.visible,
      security: this.options.security,
      opacity: this.opacity
    };
  }

  constructor(public options: LayerOptions) {
    this.initDisplayed$$();
  }

  afterCreated(): void {
    if (this.options.zIndex !== undefined) {
      this.zIndex = this.options.zIndex;
    }

    if (this.options.baseLayer && this.options.visible === undefined) {
      this.options.visible = false;
    }

    this.maxResolution =
      this.options.maxResolution ||
      getResolutionFromScale(Number(this.options.maxScaleDenom));
    this.minResolution =
      this.options.minResolution ||
      getResolutionFromScale(Number(this.options.minScaleDenom));

    this.visible =
      this.options.visible === undefined ? true : this.options.visible;
    this.opacity =
      this.options.opacity === undefined ? 1 : this.options.opacity;
  }

  init(map: MapBase): void {
    this.map = map;
  }

  add(parent?: LayerGroupBase): void {
    this._add(parent);
  }

  private _add(parent?: LayerGroupBase): void {
    this.addParent(parent);
    this.parent ? this.parent.addChild(this) : this.map.ol.addLayer(this.ol);
  }

  addParent(parent?: LayerGroupBase): void {
    if (this.parent && this.parent === parent) {
      return;
    }

    this.parent = parent;

    if (!this.map && this.parent) {
      this.map = this.parent.map;
    }

    this.initDisplayed$$();
  }

  remove(): void {
    this._remove();
  }

  private _remove(): void {
    if (!this.map) {
      console.error(`No map for ${this.title}`);
      return;
    }
    this.parent
      ? this.parent.removeChild(this)
      : this.map.ol.removeLayer(this.ol);
    this.dataSource?.destroy();
  }

  reset(parent?: LayerGroupBase): void {
    this._remove();
    this._add(parent);
  }

  moveTo(parent?: LayerGroupBase): void {
    if (parent == null && this.parent == null) {
      return;
    }

    if (this.parent) {
      if (this.parent.id === parent?.id) {
        return;
      }
    }

    this.reset(parent);
  }

  clone(): LayerBase {
    const clone = Object.assign({}, this);
    return Object.setPrototypeOf(clone, LayerBase.prototype);
  }

  private initDisplayed$$(): void {
    this.displayed$$?.unsubscribe();

    const obs$ = [this.isInResolutionsRange$, this.visible$];

    if (this.parent) {
      obs$.push(this.parent.displayed$);
    }

    this.displayed$$ = combineLatest(obs$).subscribe(
      ([inRes, visible, parentDisplayed = null]) => {
        const isVisible = this.parent ? parentDisplayed && visible : visible;
        this.displayed = isVisible && inRes;
      }
    );
  }
}

export abstract class LayerGroupBase extends LayerBase {
  type: LayerType = 'group';
  children: LayerBase[];

  abstract get descendants(): LayerBase[];

  abstract addChild(layer: LayerBase): void;
  abstract removeChild(layer: LayerBase): void;
  abstract isDescendant(layer: LayerBase): boolean;
}
